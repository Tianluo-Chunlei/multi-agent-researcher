# Building Effective AI Agents - 深度总结

## 文章概述
这篇文章来自 Anthropic 团队，基于他们与数十个团队合作构建 LLM 智能体的经验。核心观点是：**最成功的实现使用简单、可组合的模式，而不是复杂的框架**。

## 一、核心概念与定义

### 1.1 智能体系统的分类
Anthropic 将所有变体归类为 **agentic systems（智能体系统）**，但在架构上区分两种类型：

- **Workflows（工作流）**：通过预定义代码路径编排 LLM 和工具的系统
- **Agents（智能体）**：LLM 动态指导自己的流程和工具使用，维持对任务完成方式的控制

### 1.2 何时使用智能体
- 推荐原则：**先找最简单的解决方案，只在需要时增加复杂性**
- 权衡：智能体系统通常以延迟和成本换取更好的任务性能
- 选择建议：
  - 工作流：适用于定义明确的任务，提供可预测性和一致性
  - 智能体：适用于需要灵活性和模型驱动决策的场景

## 二、构建模块和工作流模式

### 2.1 基础构建块：增强型 LLM
基础构建块是通过以下增强功能增强的 LLM：
- **Retrieval（检索）**
- **Tools（工具）** 
- **Memory（记忆）**

实现建议：
- 针对特定用例定制这些功能
- 确保为 LLM 提供简单、文档良好的接口
- 可使用 Model Context Protocol (MCP) 集成第三方工具

### 2.2 工作流模式

#### 模式 1：Prompt Chaining（提示链）
- **描述**：将任务分解为一系列步骤，每个 LLM 调用处理前一个的输出
- **适用场景**：任务可以轻松分解为固定子任务
- **示例**：
  - 生成营销文案，然后翻译成不同语言
  - 先写大纲，检查大纲，再基于大纲写文档

#### 模式 2：Routing（路由）
- **描述**：对输入进行分类并将其定向到专门的后续任务
- **适用场景**：存在不同类别需要分别处理的复杂任务
- **示例**：
  - 将不同类型的客服查询路由到不同流程
  - 简单问题路由到小模型，复杂问题路由到大模型

#### 模式 3：Parallelization（并行化）
两种变体：
- **Sectioning（分节）**：将任务分解为并行运行的独立子任务
- **Voting（投票）**：多次运行相同任务以获得多样化输出

**示例**：
- 实现保护措施：一个模型处理用户查询，另一个筛查不当内容
- 代码漏洞审查：多个提示审查并标记问题

#### 模式 4：Orchestrator-Workers（协调器-工作者）
- **描述**：中央 LLM 动态分解任务，委派给工作者 LLM，并综合结果
- **适用场景**：无法预测所需子任务的复杂任务
- **示例**：对多个文件进行复杂更改的编码产品

#### 模式 5：Evaluator-Optimizer（评估器-优化器）
- **描述**：一个 LLM 生成响应，另一个在循环中提供评估和反馈
- **适用场景**：有明确评估标准，迭代改进提供可衡量价值
- **示例**：文学翻译、需要多轮搜索和分析的复杂搜索任务

## 三、自主智能体

### 3.1 智能体的工作流程
1. 从人类用户接收命令或进行交互式讨论
2. 任务明确后，独立规划和操作
3. 在每一步从环境获取"ground truth"（如工具调用结果）
4. 在检查点或遇到阻塞时暂停以获取人类反馈
5. 完成时终止，或达到停止条件（如最大迭代次数）

### 3.2 实施要点
- 智能体通常只是在循环中基于环境反馈使用工具的 LLM
- **关键**：清晰、深思熟虑地设计工具集及其文档
- 需要在沙盒环境中进行广泛测试
- 设置适当的保护措施

### 3.3 应用示例
- SWE-bench 任务的编码智能体
- "Computer use" 参考实现

## 四、实践中的智能体应用

### 4.1 客户支持
优势：
- 支持交互自然遵循对话流程
- 可集成工具拉取客户数据、订单历史
- 可编程处理退款、更新工单等操作
- 成功可通过用户定义的解决方案明确衡量

### 4.2 编码智能体
优势：
- 代码解决方案可通过自动测试验证
- 智能体可使用测试结果作为反馈迭代解决方案
- 问题空间定义明确且结构化
- 输出质量可客观衡量

## 五、最佳实践

### 5.1 框架使用建议
- 框架（如 LangGraph、Amazon Bedrock AI Agent）简化了标准任务
- **建议**：从直接使用 LLM API 开始，许多模式只需几行代码
- 如果使用框架，确保理解底层代码
- 避免添加不必要的复杂性

### 5.2 工具工程
工具设计原则：
1. **为模型提供足够的"思考"空间**
2. **格式接近互联网上自然出现的文本**
3. **避免格式化开销**（如准确计数代码行数、字符串转义）

工具优化建议：
- 站在模型的角度思考：工具是否易于使用？
- 良好的工具定义包括：示例用法、边缘情况、输入格式要求、与其他工具的清晰边界
- 测试模型如何使用工具，迭代改进
- **Poka-yoke（防错）设计**：更改参数使其更难出错

### 5.3 三个核心原则
1. **保持设计简单性**
2. **优先透明性**：明确显示智能体的规划步骤
3. **精心设计智能体-计算机接口（ACI）**：通过全面的工具文档和测试

## 六、关键洞察与建议

### 6.1 复杂性管理
- 只在能够明显改善结果时才添加复杂性
- 从简单提示开始，通过全面评估优化
- 只有当简单解决方案不足时才添加多步骤智能体系统

### 6.2 成功的关键
- 成功不在于构建最复杂的系统，而在于构建适合需求的正确系统
- 可以根据不同用例塑造和组合这些构建块
- 关键是衡量性能并迭代实现

### 6.3 投资重点
- 工具定义和规范应该获得与整体提示同等的工程关注
- 在 SWE-bench 智能体构建中，团队花在优化工具上的时间超过了整体提示

## 七、总结

这篇文章提供了构建有效 AI 智能体的实用指南，强调了简单性、可组合性和迭代改进的重要性。主要观点：

1. **简单优于复杂**：最成功的实现使用简单、可组合的模式
2. **渐进式复杂性**：只在需要时增加复杂性
3. **工具是关键**：精心设计的工具和接口对智能体成功至关重要
4. **测量和迭代**：持续测量性能并迭代改进
5. **人机协作**：保持适当的人类监督和反馈循环

这些原则和模式为构建可靠、可维护且受用户信任的智能体系统提供了坚实的基础。